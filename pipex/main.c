/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rkobeiss <rkobeiss@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/03 18:56:57 by rkobeiss          #+#    #+#             */
/*   Updated: 2025/09/23 18:54:19 by rkobeiss         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*infile "cmdIN" "cmdOUT" outfile
**infile is created manually
**outfile should be auto-generated by a function where name is specified as argv3
**i think use pipe[0] to receive output from terminal and input [1] data into it
**fork the processes one for in and one for out i think?
**handle errors like shell 
**F_OK and X_OK are used to determine if path exists in
** file\ directory using access function
**use dup2(pipe[0\1] to manipulate the pipes)
**if (child) dup2(pipefd[0\1] close remaining fd and execute else parent
**and then force parent to wait for child by usng waitpid() that waits for
**specific child o finish)*/

#include <unistd.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <stdio.h>
#include "pipex.h"

void	cleanup_and_exit(char *path, char **temp, char **paths, int code)
{
	if (path)
		free(path);
	if (temp)
		free_paths(temp);
	if (paths)
		free_paths(paths);
	exit(code);
}

void	free_paths(char **strs)
{
	int	i;

	i = 0;
	if (!strs)
		return ;
	while (strs[i])
	{
		free(strs[i]);
		i++;
	}
	free(strs);
}

int	end(int pid1, int pid2, int *pipefd)
{
	int	status;

	close(pipefd[0]);
	close(pipefd[1]);
	waitpid(pid1, NULL, 0);
	waitpid(pid2, &status, 0);
	if (WIFEXITED(status))
		return (WEXITSTATUS(status));
	return (1);
}

int	main(int argc, char **argv, char **env)
{
	int		pipefd[2];
	t_pipe	pipes;
	int		pid1;
	int		pid2;
	char	**paths;

	pipes.env = env;
	pipefd[0] = -1;
	pipefd[1] = -1;
	if (argc != 5)
		return (1);
	if (pipe(pipefd) == -1)
		return (1);
	paths = get_path(env);
	if (!paths)
		cleanup_and_exit(NULL, NULL, NULL, 1);
	pid1 = fork();
	if (!pid1)
		cmd1(pipefd, argv, paths, pipes);
	pid2 = fork();
	if (!pid2)
		cmd2(pipefd, argv, paths, pipes);
	free_paths(paths);
	return (end(pid1, pid2, pipefd));
}
